import 'dart:convert';import 'package:http/http.dart' as http;import '../../../core/constants/app_constants.dart';import '../models/message_model.dart';/// Google Gemini API와 통신하여 AI 기반 기능을 제공하는 서비스 클래스입니다./// 주어진 프롬프트와 대화 기록을 바탕으로 텍스트 응답을 생성하고,/// 스트리밍 응답을 통해 점진적으로 텍스트를 받아올 수 있습니다.class GeminiService {  static const String _baseUrl = AppConstants.geminiApiBaseUrl;  final String _apiKey;  /// [apiKey]를 사용하여 GeminiService를 초기화합니다.  GeminiService({required String apiKey}) : _apiKey = apiKey;  /// 단일 응답을 생성합니다.  /// [prompt]와 이전 [conversationHistory]를 기반으로 Gemini API를 호출하여  /// 완전한 텍스트 응답을 반환합니다.  Future<String> generateResponse({    required String prompt,    List<MessageModel>? conversationHistory,  }) async {    try {      final url = Uri.parse('$_baseUrl/models/gemini-pro:generateContent?key=$_apiKey');            final messages = _buildMessages(prompt, conversationHistory);            final response = await http.post(        url,        headers: {          'Content-Type': 'application/json',        },        body: jsonEncode({          'contents': messages,          'generationConfig': {            'temperature': 0.7,            'topK': 40,            'topP': 0.95,            'maxOutputTokens': 2048,          },          'safetySettings': [            {              'category': 'HARM_CATEGORY_HARASSMENT',              'threshold': 'BLOCK_MEDIUM_AND_ABOVE'            },            {              'category': 'HARM_CATEGORY_HATE_SPEECH',              'threshold': 'BLOCK_MEDIUM_AND_ABOVE'            },            {              'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',              'threshold': 'BLOCK_MEDIUM_AND_ABOVE'            },            {              'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',              'threshold': 'BLOCK_MEDIUM_AND_ABOVE'            },          ],        }),      );      if (response.statusCode == 200) {        final data = jsonDecode(response.body);        return data['candidates'][0]['content']['parts'][0]['text'];      } else {        throw Exception('Failed to generate response: ${response.statusCode}');      }    } catch (e) {      throw Exception('Error calling Gemini API: $e');    }  }  /// 스트리밍 방식으로 응답을 생성합니다.  /// [prompt]와 이전 [conversationHistory]를 기반으로 Gemini API를 호출하여  /// 응답을 스트림 형태로 반환합니다. 텍스트가 생성되는 대로 조각(chunk)을 받아볼 수 있습니다.  Stream<String> generateStreamResponse({    required String prompt,    List<MessageModel>? conversationHistory,  }) async* {    try {      final url = Uri.parse('$_baseUrl/models/gemini-pro:streamGenerateContent?key=$_apiKey');            final messages = _buildMessages(prompt, conversationHistory);            final request = http.Request('POST', url);      request.headers['Content-Type'] = 'application/json';      request.body = jsonEncode({        'contents': messages,        'generationConfig': {          'temperature': 0.7,          'topK': 40,          'topP': 0.95,          'maxOutputTokens': 2048,        },      });      final streamedResponse = await request.send();            if (streamedResponse.statusCode == 200) {        await for (final chunk in streamedResponse.stream.transform(utf8.decoder)) {          final lines = chunk.split('
');          for (final line in lines) {            if (line.startsWith('data: ')) {              final jsonStr = line.substring(6);              if (jsonStr.trim().isNotEmpty && jsonStr != '[DONE]') {                try {                  final data = jsonDecode(jsonStr);                  if (data['candidates'] != null && data['candidates'].isNotEmpty) {                    final text = data['candidates'][0]['content']['parts'][0]['text'];                    yield text;                  }                } catch (e) {                  // Skip invalid JSON chunks                }              }            }          }        }      } else {        throw Exception('Failed to generate stream response: ${streamedResponse.statusCode}');      }    } catch (e) {      throw Exception('Error calling Gemini streaming API: $e');    }  }  /// Gemini API 요청에 필요한 메시지 목록을 구성합니다.  /// 시스템 메시지, 대화 기록, 현재 프롬프트를 포함하는 메시지 목록을 생성합니다.  List<Map<String, dynamic>> _buildMessages(    String prompt,    List<MessageModel>? conversationHistory,  ) {    final messages = <Map<String, dynamic>>[];        // Add system message for Flutter development context    messages.add({      'role': 'user',      'parts': [{        'text': '''당신은 Flutter 개발 전문가입니다. 사용자의 요청에 따라 다음과 같은 작업을 수행할 수 있습니다:

1. Flutter 위젯 및 화면 코드 생성
2. 코드 분석 및 디버깅
3. UI/UX 개선 제안
4. Firebase 연동 코드 작성
5. Git 관련 작업 안내

항상 한국어로 친절하고 자세하게 설명해주세요. 코드를 생성할 때는 주석을 포함하여 이해하기 쉽게 작성해주세요.'''      }]    });    // Add conversation history    if (conversationHistory != null) {      for (final message in conversationHistory.take(10)) { // Limit to last 10 messages        messages.add({          'role': message.type == MessageType.user ? 'user' : 'model',          'parts': [{'text': message.content}]        });      }    }    // Add current prompt    messages.add({      'role': 'user',      'parts': [{'text': prompt}]    });    return messages;  }}